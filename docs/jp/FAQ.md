### **Open Match \- よくある質問とチューニングガイド**

ここでは、Open Matchのチューニング、設定、およびベストプラクティスに関する一般的な質問への回答を掲載しています。

#### **チューニングとパフォーマンス**

**Q: Open Matchコアインスタンスが状態のレプリケーションに追いついているかを知るにはどうすればよいですか？**

A: `om_core.cache.incoming.updates`と`om_core.cache.incoming.timeouts.full`のメトリクスを監視する必要があります 。

* `om_core.cache.incoming.updates`: このメトリクスは、インスタンスが各ポーリングサイクルで処理する更新数を示します 。 この数値が時折、設定された最大値（`OM_CACHE_IN_MAX_UPDATES_PER_POLL`）にスパイクするのは正常です 。 しかし、このメトリクスが**常に**最大値である場合、インスタンスがRedisからの更新を到着する速さで処理できていない兆候である可能性があります 。  
* `om_core.cache.incoming.timeouts.full`: このカウンターは、インスタンスが内部の制限時間内に保留中のすべての更新を処理できなかった場合にインクリメントされます 。 時折のインクリメントは問題ありませんが、このカウンターが急速に増加している場合、インスタンスがレプリケーションに遅れている明確な兆候です 。

これらの兆候が見られる場合は、`OM_CACHE_IN_SLEEP_BETWEEN_APPLYING_UPDATES_MS`の値を下げてみることができます 。 このスリープ時間からミリ秒を削除するたびに、コアプロセスがAPIコールの処理に費やせないミリ秒が生まれるため、トレードオフが存在することに注意してください 。

**Q: マッチを返す前にチケットの非アクティブ化を待つべきですか（`OM_MATCH_TICKET_DEACTIVATION_WAIT`）？**

A: この設定は、速度と一貫性の間のトレードオフを制御します 。

* `true`（デフォルト＆推奨）：Open Matchは、マッチ内のすべてのチケットがローカルキャッシュで`inactive`としてマークされたことを確認するまで待機してから、マッチをDirectorに返します 。 これはより安全であり、同じチケットが別のMMFによって他のマッチで提案される可能性を大幅に減少させます 。  
* `false`: Open Matchはすぐにマッチを返し、**その後**チケットの非アクティブ化を試みます 。 こちらの方が高速ですが、安全性は劣ります 。 非アクティブ化がレプリケートされる前に、別のマッチメイキングサイクルが開始され、同じチケットが新しいマッチで提案される可能性があります 。

**Q: `InvokeMatchmakingFunctions`の実行中にマッチメーカーがコンテキストをキャンセルするとどうなりますか？**

A: コンテキストをキャンセルすると、システムが不明な状態になり、避けるべきです 。 `InvokeMatchmakingFunctions`の呼び出しは、すでにマッチをDirectorに送り返しており、それらのマッチのチケットの非アクティブ化が進行中である可能性があります 。 もしキャンセルして回復する必要がある場合は、システムをマッチメーカーが期待する状態に復元するために、必要に応じて手動でチケットをアクティブ化または非アクティブ化する責任があります 。

#### **状態ストレージ（Redis）**

**Q: Redisの永続化やクラスタリングは必要ですか？ Redisインスタンスがダウンするとどうなりますか？**

A: Redisの永続化（AOFやRDBなど）は選択肢の一つですが、それがあなたのゲームのニーズに合っているか慎重に検討すべきです 。 プライマリのRedisインスタンスがダウンした場合、典型的なフェイルオーバーには最大30秒かかることがあります 。 その時間内に、ほとんどのマッチメイキングチケットはどのみち古くなってしまいます 。 多くのゲームにとって、Redisのフェイルオーバーを待って古い可能性のあるデータで再開するよりも、クライアントが短い遅延の後にマッチメイキングリクエストを単純に再試行する方が、プレイヤーエクスペリエンスは向上します 。

**Q: スケーリングのために複数のRedisインスタンスを使用するようにOpen Matchを設定できますか？**

A: はい、でもあり、いいえ、でもあります 。

* **リードレプリカ（はい）**: Open MatchはRedisのリードレプリカを使用するための組み込みサポートがあります 。 読み取り操作用に別のホスト（`OM_REDIS_READ_HOST`）と、書き込み操作用に別のホスト（`OM_REDIS_WRITE_HOST`）を設定できます 。 これは読み取り負荷の高いワークロードをスケールさせるための一般的で効果的な方法です 。  
* **シャーディング（いいえ）**: Open MatchはRedisのシャーディングをサポートしていません 。 単一の書き込みインスタンスが任意のキーの書き込みを受け入れることができ、すべての読み取りインスタンスが書き込まれたすべてのデータを参照できることを前提としています 。

#### **設定とベストプラクティス**

**Q: OpenTelemetry接続がデフォルトでTLSを使用しないのはなぜですか？**

A: デフォルト設定では、Open MatchコアとOpenTelemetryコレクターが同じセキュアな実行コンテキスト（Kubernetes PodやCloud Runサービスなど）内でサイドカーとして実行されていることを想定しています 。 この環境では、トラフィックはセキュアな境界から外に出ず、通常TLSは必要ありません 。 もしデプロイメントで必要な場合は、この接続を保護する責任はあなたにあります 。

**Q: 「バックフィル」プロファイルと通常のプロファイルはどのように扱うべきですか？**

A: 部分的に空いている実行中のゲームサーバーを埋めるために設計されたプロファイルがある場合、一般的には、全く新しいマッチを作成するためのMMFを呼び出す**前**に、これらのプロファイルのためのMMFを呼び出すべきです 。 なぜなら、通常のプロファイルは利用可能なプレイヤーのプールを非常に迅速に枯渇させる可能性があるからです 。 あなたのゲームのロジックに最も適したMMF呼び出しの順序を決定するのは、あなたのDirectorの責任です 。

**Q: 作成直後にチケットの有効期限が切れました。何が起こったのですか？**

A: Open Matchは常にチケットの有効期限をその`creation_time`に基づいて計算します 。 もし非常に古い`creation_time`（例えば、1970年1月1日のUNIXエポック）を手動で提供し、デフォルトのTTLが10分である場合、チケットは作成された瞬間に有効期限切れと見なされます 。

**Q: チケットの有効期限切れを防ぐために、非常に長いTTLを設定してもよいですか？また、`OM_CACHE_TICKET_TTL_MS`の適切な値はどのように計算すべきですか？**

A: エッジケースや「いつまでも終わらない」キューを処理するためにこの設定を使用しないでください。TTLが長すぎると、正常にマッチングした（非アクティブな）チケットが、TTLが切れるまでシステムメモリ内に蓄積され続けることになり、負荷とメモリ圧迫の原因となります。この値は、プレイヤーベースの95%（正規分布を仮定）がマッチを見つけるのにかかる時間よりも「少しだけ長く」設定すべきですが、それ以上長くしてはいけません。

この数値を導き出すための実践的な例を挙げます：

1. マッチメイキングデータの分析: プレイヤーの大部分がマッチを見つけるのにかかる時間を特定します。例えば、プレイヤースキルの分布が正規分布である場合、プレイヤーの95%が5分以内にマッチングされることがわかるかもしれません。
1. 「ハードデッドライン」の定義: マッチメーカーが抜本的なアクション（より広いパラメータでの検索再開や、プレイヤーへの再試行の提案など）を取るまでに、プレイヤーが待機すべき最大時間を決定します。ここでは仮に7分とします。
1. TTLの設定: OM_CACHE_TICKET_TTL_MSを、そのハードデッドラインよりも少しだけ長く設定します（例：7分30秒）。

7分以上待機しているプレイヤーはエッジケースです。これらのプレイヤーについては、高度なトピックのドキュメントにある「長寿命チケットの取り扱い」パターンを使用して対処すべきです。具体的には、クライアントやフロントエンドで有効期限が近づいていることを検出し、高優先度のフラグを立てて透過的に新しいチケットを再作成します。これにより、特定のプレイヤーの長い待ち時間をサポートしつつ、Open Matchコアを軽量かつ高性能に保つことができます。

**Q: `InvokeMatchmakingFunctions`は各プールにいくつのチケットがあったかを教えてくれないのはなぜですか？**

A: Open Matchは、この情報があなたにとって重要である場合、それを追跡するのはあなたのMMFの責任であると想定しています 。 あなたのMMFは、受け取ったプール内のチケットを数え、このデータを返す`Match`オブジェクトの`extensions`フィールドに含めることができます 。

**Q: プロファイル名に逆DNS記法を使用すべきなのはなぜですか？**

A: これはメトリクスのカーディナリティを管理するためのベストプラクティスです 。 テレメトリシステムは、ユニークなラベルが多すぎると圧倒される可能性があります 。 `com.mygame.gamemode.ranked-4v4.us-west1.2025-09-2718:00:00.000`のような形式を使用することで、監視ツールは名前の最も具体的な部分を取り除くことで簡単にメトリクスを集約できます（例：`com.mygame.gamemode.ranked-4v4.us-west1`以下のすべてのメトリクスを集約する） 。

**Q: MMFから返されたマッチ内のチケットをOpen Matchが非アクティブ化するのを防ぐことはできますか？ Directorでまずマッチの品質を評価したいのです。**

A: いいえ、この振る舞いを直接無効にすることはできません。Open Matchは、あなたのMMFが返す全てのマッチのrosterに含まれるチケットを常に非アクティブ化します。

しかし、MMFに`roster`フィールドを空のままにさせ、代わりに提案されたプレイヤーをマッチの`extensions`フィールドに入れることで、この動作を回避できます。そして、あなたのDirectorが`extensions`を検査するようにコーディングすることができます。もしマッチを承認する場合、そのマッチのプレイヤーに対して手動で`DeactivateTickets`を呼び出す責任があります。

トレードオフに注意してください：あなたのDirectorがそれらのチケットを非アクティブ化するまで、それらはOpen Match内でアクティブなままであり、他のマッチメイキングサイクルに含まれる可能性があります。

#### **トラブルシューティング**

**Q: ログに`Redis Failure; exiting: dial tcp <host:port>: i/o timeout`と表示されます。**

A: これはほとんどの場合、ネットワークの問題です 。 Open Matchが実行されているサービスが正しいネットワークにデプロイされており、Redisインスタンスに到達するために必要なネットワーク出力ルールとVPCピアリング設定があることを確認してください 。

**Q: gRPC-gatewayを使用していて、クライアントが`InvokeMMFs`からのレスポンスのアンマーシャルに失敗します。**

A: これはgRPC-gatewayの動作に関する見落としやすい詳細です 。 gRPC-gatewayは、実際のレスポンスペイロードを、キー`"result"`の下の親JSONオブジェクト内にラップします 。 レスポンスをアンマーシャルする際には、protobufのJSONアンマーシャラーに渡す前に、まず`"result"`キーの内容を抽出する必要があります 。

#### **責任の分担**

**Q: マッチング中に時々発生するエッジケースがあります。Open Matchがそれを処理してくれますか？**

A: Open Matchの設計思想は、特定のエッジケースの扱い方について意見を持たない（unopinionated）ことです。あるエッジケースへの対処がOpen Matchで可能であったとしても、ほとんどのマッチメーカーでも同様に対処が必要となる場合、その責任はマッチメーカーに委ねられます。このアプローチにより、Open Matchの振る舞いは一貫性を保ち、規範的になることを避けています。例えば、あるゲームで破棄されたマッチが、別のゲームではバックフィルの機会となることがあります。

あなたのマッチメーカーが処理すべき障害状態の他の例については、このFAQの**障害ハンドリング**のセクションを参照してください。

#### **障害ハンドリング**

**Q: マッチメーカーが処理する必要がある障害状態は何ですか？**

A: あなたのマッチメーカーは、分散システムの現実に耐えうるものでなければなりません 。 Open Matchの結果整合性モデルは、あなたのコードがすでに多くのシナリオに対して堅牢である必要があることを意味します 。 対処しなければならない主要な障害状態は次のとおりです ：

* **消えるプレイヤー**: プレイヤーはいつでも切断したり、マッチメイキングをキャンセルしたりする可能性があります 。 あなたのシステムには、これを検出し、`DeactivateTickets`を呼び出して彼らをプールから削除する方法が必要です 。  
* **消えるサーバー**: 利用可能だったゲームサーバーが不健康になったり、ネットワーク障害を起こしたりする可能性があります 。 サーバーの割り当てが失敗した場合、または割り当ては成功したもののプレイヤーが決して接続できなかった場合の解決策は何でしょうか？  
* **競合するマッチ提案**: 高度なMMFパターンで議論したように、あなたのDirectorは同じチケットに対して競合するマッチ提案を受け取り、それらの衝突を解消し、破棄されたマッチからのチケットを再アクティブ化するロジックを持たなければなりません 。

