
# **Open Match 2：技術的進化**

このドキュメントでは、Open Match 1（OM1）とOpen Match 2（OM2）の詳細な技術的比較を行い、主要なアーキテクチャと設計の変更点に焦点を当てます。

## **統一された柔軟なコアアーキテクチャとデプロイメント**

OM2における最も重要なアーキテクチャの変更は、分散マイクロサービスアーキテクチャからom-coreと呼ばれる単一の統一バイナリへの移行です。OM1では、frontend、backend、queryといったコンポーネントは個別のデプロイメントでした。OM2はそれらの機能を単一のステートレスサービスに統合し、デプロイメントと管理を簡素化し、多くの操作でネットワークホップ数を削減します。

om-coreサービスの各インスタンスは、完全に独立して動作するように設計されています。それぞれがRedisへの独自の読み取りおよび書き込み接続を確立し、ゲームクライアントサービス（CreateTicket RPCによるチケット作成）とマッチメーカー（InvokeMatchmakingFunctionsを呼び出すdirector）の両方からのAPIリクエストを処理できます。

この統一された設計は、高度なデプロイメントパターンを妨げるものではありません。アーキテクチャは、異なる目的のために水平スケールされたom-coreインスタンスの個別プールを実行する機能を明示的にサポートしています。例えば、大量のCreateTicketリクエスト専用に大規模な自動スケーリングプールを維持し、一方で、頻度は低いがリソースをより集中的に使用するInvokeMatchmakingFunctions呼び出し用に別の小規模なプールを運用することが可能です。この柔軟性を妨げる設計上の妥協がないよう努めました。

#### **APIレイヤー：より正確で合理化されたインターフェース**

OM2のAPIは、明確さと効率性を追求して再設計され、RPCシグネチャとメッセージ構造に顕著な変更が加えられました。

CreateTicket RPCはその代表例です。OM1では、TicketをCreateTicketRequestメッセージでラップする必要がありました。OM2のOpenMatchServiceは、リクエストボディとしてpb.Ticketメッセージを直接受け入れることでこれを簡素化し、定型的なコードを削減しています。

さらに、OM2のTicketメッセージ自体も合理化されました。OM1のトップレベルのTicket（messages (om1).txt）にあったassignmentフィールドは削除されました。OM2（messages (om2).txt）では、Ticketは純粋にマッチメイキングデータのコンテナとなり、最終的なアサインメントから完全に切り離されています。

推奨されるクライアントの対話方法も変わりました。OM1クライアントが純粋なgRPCを使用していたのに対し、OM2の例（omclient.go）では、gRPC-Gatewayを介して標準のHTTPクライアントを使用する方法が示されています。これは、堅牢なサーバーサイドのHTTPロードバランシングが、複雑なクライアントサイドのgRPCロードバランシングよりも管理が容易であることが多く、インフラを簡素化するために行われました。

#### **ステートマネジメント：Redisリードレプリカに最適化**

Open Match 2は、各om-coreインスタンス内にReplicatedTicketCacheを導入し、ステートストアへの直接クエリを削減します。Redisを使用する本番環境では、ステートマネジメントはシンプルで効果的なスケーリングパターンを活用するように特別に設計されています。

各om-coreインスタンスは、個別の**読み取り用および書き込み用のRedisエンドポイント**で構成されます。このサービスは、Redisのリードレプリカを使用して水平にスケールするよう完全に設計されています。典型的な本番トポロジでは、すべてのインスタンスが書き込み構成を単一のRedisプライマリインスタンスに向けます。一方、読み取り構成は1つ以上のリードレプリカに向けられます。これにより、大量のチケットプーリングの読み取り負荷を複数のレプリカに分散させ、マッチメイキングシステムの読み取りスループットを劇的に向上させることができます。この設計は、Redis ClusterやRedis Sentinelのような運用上複雑なトポロジを必要とせず、よりシンプルなインフラで大規模なスケーラビリティを提供します。

#### **マッチ解決とチケット衝突ハンドリング**

OM2の根本的な再設計の一つは、**Synchronizer**と**Evaluator**コンポーネントを削除し、**チケット衝突**のハンドリング責任を開発者に移すことで、マッチ解決プロセスを簡素化した点です。

OM1では、MMFは*マッチ提案*を作成しました。evaluatorは、複数の提案に同じチケットが含まれる「チケット衝突」を解決するために開発者が記述する必須のサービスでした。このプロセスは複雑であり、そのニュアンスが開発者に見過ごされ、パフォーマンス問題を引き起こすことがありました。

OM2は**evaluatorとsynchronizerを完全に削除**しました。OM2はもはやチケット衝突を認識しません。OM2のMatchオブジェクト（messages (om2).txt）は、最終的なAssignmentを含む完全で権威あるエンティティです。対照的に、OM1のMatchは一時的な提案でした。新しいフローでは、2つのMMFが重複したチケットを持つマッチを返した場合、OM2は介入しません。開発者の**マッチメーカー**が、マッチを受信した後に自身のロジックでこの衝突を処理する責任を負います。この変更は、同期ウィンドウをなくすことで大幅なパフォーマンス向上をもたらし、開発者が自身のアーキテクチャに最適な方法で衝突ハンドリングを実装できる柔軟性を提供します。

#### **アサインメントの再考：ポーリングからプッシュへ**

アサインメントの取得プロセスは、スケーラビリティを向上させるために完全に再設計されました。OM1のクライアントサイドのポーリングモデルは、今や明確なアンチパターンと見なされています。

OM1では、クライアントはFrontendServiceのGetAssignments RPCを呼び出し、om-frontendサービスに繰り返し問い合わせる長いポーリングループに入りました。

OM2では、このモデルは非推奨です。OpenMatchServiceのapi.txt定義では、WatchAssignmentsおよびCreateAssignments RPCに// \*\*\* NOTE: DEPRECATED RPCs BELOW, DO NOT USE IN PRODUCTION \*\*\*というコメントが明記されています。これらのエンドポイントは、移行を容易にするための一時的なブリッジとしてのみ提供されます。

OM2で推奨される正しいパターンは、マッチメーカーが全てのアサインメントロジックを処理することです 。MMFが最終的なMatch（チケットのグループ）を作成した後、マッチメーカーがInvokeMatchmakingFunctionsストリームからそのMatchを受け取ります。続いて、どのゲームサーバーにマッチを割り当てるかを決定し 、そのアサインメント情報をプレイヤーやゲームサーバーに直接プッシュする責任を負います 。この一元化されたモデルにより、マッチメイキングシステムへの負荷が劇的に削減されます 。

## **v1からv2へのOpen Matchチケットクライアントの移行**

このセクションでは、ゲームクライアントコード（チケットを作成するアプリケーションの部分）をOpen Match 1（OM1）APIから、新しく合理化されたOpen Match 2（OM2）APIへ更新する方法について説明します。

#### **1\. 接続の更新：gRPCからHTTPへ**

最も重要なインフラの変更は、直接的なgRPC接続から、組み込みのgRPC-Gatewayを活用したHTTPベースの接続への移行です。これにより、シンプルさと堅牢な負荷分散が実現します。

* **OM1 (client.go)では、** クライアントは純粋なgRPCクライアントを使用してom-frontendサービスに直接接続していました。  
* **OM2 (omclient.go)では、** 推奨されるパターンは、標準のHTTPクライアントを使用することです。ProtobufリクエストはJSONにマーシャリングされ、HTTP経由でom-coreサービスに送信されます。om-coreサービスはサーバーサイドでgRPCへのトランスコーディングを処理します。  
* **なぜ変更されたのか？** これはクライアントサイドのインフラを簡素化するためです。gRPCは高性能ですが、クライアントサイドの負荷分散は複雑になる可能性があります。OM2はHTTPインターフェースを提供することで、クラウドプロバイダーが提供する堅牢で業界標準のサーバーサイドHTTPロードバランサーの使用を可能にし、デプロイメントを簡素化し、信頼性を向上させます。

#### **2\. 新しいアサインメントフロー**

マッチのアサインメントを取得する方法は、スケーラビリティを向上させるために完全に再設計されました。OM1のクライアントサイドポーリングモデルは、現在では明確なアンチパターンとされています。

* **OM1 (frontend.txt)では、** クライアントはGetAssignments RPCを呼び出し、マッチが見つかるまでom-frontendサービスに繰り返しクエリする長いポーリングループに入りました。  
* **OM2では、** このモデルは非推奨です。OpenMatchServiceのapi.txt定義では、WatchAssignments RPCに// \*\*\* NOTE: DEPRECATED RPCs BELOW, DO NOT USE IN PRODUCTION \*\*\*（注意：以下のRPCは非推奨であり、本番環境では使用しないでください）というコメントが明記されています。  
* 正しいOM2のパターンは、クライアントの責任がチケットを正常に作成した時点で終了することです。アサインメントのロジックは、完全なMatchオブジェクトを受け取る**マッチメーカー**によって処理されるようになりました。クライアントは、Open Matchからではなく、自社のゲームのバックエンドサービスからのプッシュ通知を待つべきです。

#### **3\. Ticket Protobuf定義の変更**

Ticketメッセージ自体もバージョン間で進化し、より大きなアーキテクチャの変更を反映しています。

| Open Match 1 (messages (om1).txt) | Open Match 2 (messages (om2).txt) | 変更点の分析 |
| :---- | :---- | :---- |
| Assignment assignment | フィールド削除 | AssignmentはもはやTicketの状態の一部ではなくなり、クライアントの責任がチケット作成時に終了することを強調しています。 |
| SearchFields search\_fields | Attributes attributes | 明確化のために名前が変更されました。このフィールドは引き続き検索可能なタグとフィルタリング用のキー/値データを保持しますが、より論理的な名前になりました。 |
| google.protobuf.Timestamp create\_time | protoからフィールド削除、expiration\_time追加 | create\_timeフィールドはTicketメッセージ定義の一部ではなくなりました。このタイムスタンプは、チケットが永続化される際に、基礎となる状態複製レイヤー（Redis Streams）によって自動的に生成されるようになりました。新しいexpiration\_timeフィールドがメッセージに追加され、開発者がチケットのライフサイクルとキャッシュ内の生存期間（TTL）を明示的に制御できるようになりました。 |

#### **4\. チケットIDの生成**

OM2における重要な変更点は、独自のカスタムチケットIDを設定できなくなったことです。

Open Match 2では、チケットIDはコアサービスによって生成され、基礎となる複製システム（具体的にはRedis StreamのエントリID）に本質的にリンクされています。CreateTicket呼び出しから返されるTicketのidフィールドが、Open Match内でのそのチケットの最終的で権威あるIDです。

アプリケーションが独自のカスタム識別子を使用してチケットを追跡する必要がある場合、推奨されるパターンは、その識別子をチケット自体の検索可能な属性として含めることです。例えば、チケット作成時にカスタムIDを文字列属性として追加できます：

ticket.attributes.string\_args\["custom\_id"\] \= "your-unique-game-id"

これにより、内部ID生成システムに干渉することなく、後でカスタムIDに関連付けられたOpen Matchのチケットをクエリできます。

#### **5\. チケットの削除とライフサイクル管理**

Open Match 2におけるチケットのライフサイクルは、OM1とは根本的に異なります。手動での削除はサポートされなくなり、自動化された時間ベースの有効期限切れシステムに置き換えられました。

マッチメイキングの対象からチケットを削除するには、DeactivateTickets RPCを使用して非アクティブ化する必要があります。これにより、チケットは「非アクティブ」セットに移動され、将来のマッチメイキング機能では無視されます。すべてのチケットは、有効期限に達すると、基礎となる状態複製レイヤーによってシステムから自動的に削除されます。チケット作成時にexpiration\_timeフィールドを設定できます。未設定の場合、om-core構成（OM\_CACHE\_TICKET\_TTL\_MS環境変数）からデフォルトのチケット生存期間（TTL）が適用されます。expiration\_timeは作成後に変更できません。チケットの寿命を延ばす必要がある場合は、チケットを再作成する必要があります。これらの再作成を跨いでチケットの優先度を維持する必要があるユースケース（例：スターベーションの防止）では、extensionsフィールドにorig\_creation\_timeのようなカスタムタイムスタンプを追加し、MMFがそれを考慮するようにコーディングする必要があります。

この新しいライフサイクルモデルには、いくつかの重要な利点があります。削除を基礎となるステートストアのTTLメカニズムにオフロードすることで、**om-coreのコードが大幅に簡素化**されます。この設計は、すべてのチケットに保証された最大寿命があるため、バグや競合状態によってチケットがシステムに「リーク」する（滞留する）**以前の原因の多くを排除します**。その結果、**開発者は古いチケットや放棄されたチケットをガベージコレクションするための手動クリーンアップツールを構築または実行する必要がなくなります**。システムは設計上、自己クリーンアップ機能を備えています。

**v1からv2へのOpen Matchマッチメーカーの移行**
このセクションでは、マッチメイキングロジックを更新して、Open Match 2（OM2）のより新しく強力なAPIで動作させる方法について説明します。OM1のgRPCベースのFetchMatches/AssignTicketsパターンから、gRPC-Gateway経由でアクセス可能な新しいInvokeMatchmakingFunctionsストリーミングAPIへの進化について解説します。

まず用語について：今後、マッチメイキングをオーケストレーションする開発者記述のサービスを「**マッチメーカー**」と呼びます。定期的にマッチを取得する「director」パターンは、マッチメーカーを実装する多くの方法のうちの1つです。

#### **1\. 純粋なgRPCからgRPC-Gateway（HTTP）クライアントへの移行**

マッチメーカーにとって最も重要なインフラの変更は、直接的なgRPC接続から、gRPC-Gatewayを活用してトランスコーディングを行うHTTPベースの接続への移行です。

* **OM1 (director.go)では、** マッチメーカーは純粋なgRPCクライアントを使用してom-backendサービスに直接接続していました。

```go
// OM1: Direct gRPC connection
conn, err := grpc.Dial("om-backend.open-match.svc.cluster.local:50505", ...)
be := pb.NewBackendClient(conn)
```

* **OM2 (omclient.go & gsdirector.go)では、** 推奨されるパターンは、標準のHTTPクライアントを使用してom-coreのRESTfulエンドポイントと通信することです。このエンドポイントはgRPC-Gatewayであり、受信したHTTP/JSONリクエストをサーバーサイドでgRPC呼び出しに変換します。omclient.goファイルは、認証やprotobufのJSONへのマーシャリングなどの詳細を処理するこのための参照実装を提供します。

* **なぜ変更されたのか？** これはクライアントサイドのインフラを簡素化するためです。gRPCは高性能ですが、クライアントサイドの負荷分散は正しく実装するのが複雑になる可能性があります。OM2はHTTPインターフェースを提供することで、クラウドプロバイダーが提供する堅牢で業界標準のサーバーサイドHTTPロードバランサーの使用を可能にし、デプロイメントを簡素化し、信頼性を向上させます。

#### **2\. FetchMatchesからInvokeMatchmakingFunctionsストリームへ**

コアとなるマッチメイキングRPCは、単純なリクエストストリームから、より強力な双方向ストリームへと進化し、より動的で継続的なマッチメイキングロジックを可能にします。

* **OM1のフロー：** FetchMatches RPCは、すべてのマッチプロファイルを含む単一のリクエストを送信し、その後、レスポンスストリームからすべての結果マッチを単純なループで排出するものでした。
* **OM2のフロー：** 新しいInvokeMatchmakingFunctions RPCは、長寿命の**双方向ストリーム**です。これにより、マッチメーカーは新しいリクエストを開始することなく、同じストリーム上で新しいプロファイルや更新されたプロファイルを送信し、完了したマッチを同時に受信できます。

#### **3\. 新しいアサインメントフロー：AssignTicketsは非推奨**

OM2における重要な簡素化は、マッチメーカーのワークフローから明示的なAssignTicketsステップが削除されたことです。

* **OM1では、** FetchMatchesからマッチを受信した後、directorはゲームサーバーの接続詳細を各マッチのチケットに関連付けるために、別のAssignTickets RPC呼び出しを行う必要がありました。
* **OM2では、** この2段階のプロセスは排除されました。マッチメーカーはInvokeMatchmakingFunctionsストリームからマッチを受信し、アサインメントを行うためにOM2へ別の呼び出しを行う必要はなくなりました。代わりに、オンラインサービスのクライアント通知メカニズムに直接アサインメントを送信する責任を負います。AssignTickets RPCは現在非推奨です。

OM2は、初期の移行負担を軽減するためにom-coreサービス上にレガシーなアサインメントエンドポイントを提供しますが、これらは一時的な互換性レイヤーとしてのみ意図されています。できるだけ早くそれらから移行することを計画すべきです。

### **v1からv2へのマッチメイキング機能（MMF）の移行**

このガイドでは、Open Match 1（OM1）のAPIから、より新しく強力なOpen Match 2（OM2）のストリーミングAPIへ、あなたのマッチメイキング機能（MMF）を更新する方法を説明します。OM2におけるMMFの役割は、単なる「提案生成器」から、最終的なアサイン可能なマッチを作成するコアエンジンへと大きく向上しました。

#### **1\. MMFサービス定義の変更**

MMFの基本的なgRPC契約は、単純なリクエストストリームから、より柔軟な双方向ストリームへと進化しました。これに伴い、Run関数のシグネチャと中心的なループを変更する必要があります。

* OM1 (matchfunction.proto.txt)では、 Run RPCはリクエスト応答ストリームでした：
  rpc Run(RunRequest) returns (stream RunResponse)
  MMFは単一のRunRequestを受け取り、マッチ提案を含む1つ以上のRunResponseメッセージをストリームで返していました。
* OM2 (mmf.proto.txt)では、 Run RPCは双方向ストリームになりました：
  rpc Run(stream ChunkedMmfRunRequest) returns (stream StreamedMmfResponse)
  これは、MMFのRun関数が同じストリーム上でリクエストの受信とレスポンスの送信を同時に行い、om-coreとのより動的な対話が可能になることを意味します。

#### **2\. チケットの受信方法**

大きな簡素化点として、MMFはもはや自身のチケットを取得する責任を負わなくなりました。om-coreがこれを担当し、チケットをストリームでMMFに送信します。

* **OM1 (mmf.go)では、** MMFは能動的にチケットをクエリする必要がありました。Run関数の最初のステップは、通常matchfunction.QueryPoolsのようなヘルパーを呼び出し、Open MatchのQuery Serviceに別のRPCコールを行ってチケットプールを取得することでした。
* **OM2 (fifo.go)では、** MMFは**チケットの受動的な受信者**となります。om-coreはマッチメーカーから送られたプロファイルに基づいてチケットをクエリし、それらをMMFにストリームで*送信*します。MMFのロジックは、stream.Recv()を呼び出してChunkedMmfRunRequestメッセージを受信し、マッチングロジックを開始する前にローカルのチケットプールを構築するループから始まります。これにより、MMFにチケットクエリのロジックを含める必要がなくなります。

#### **3\. （提案ではなく）最終的なマッチの作成**

最も重要な概念的変更は、MMFの役割がもはや提案をすることではなく、最終的で権威あるマッチを作成することになった点です。

* **OM1では、** RunResponseメッセージに含まれるMatchオブジェクトは提案と見なされていました。この提案は、競合を解決し最終決定を下すために、別のEvaluatorサービスに送信されていました。
* **OM2では、** Evaluatorが削除されたため、MMFが作成するMatchが**最終的で決定的なマッチ**となります。これは、あなたのマッチメイキングロジックが信頼できる唯一の情報源として十分に堅牢でなければならないことを意味します。
